#!/usr/bin/env bun
/**
 * HeroInsight Module
 *
 * Provides daily wisdom from influential figures based on context
 * (recovery status, workout schedule, day of week, calendar events).
 *
 * This module now uses parsed dossiers for hero data instead of hardcoded arrays.
 * The heroes are loaded from the cached heroes.json file generated by ParseHeroes.ts.
 *
 * Components:
 * 1. Principle - Core teaching from the hero
 * 2. Action - Concrete action for today
 * 3. If-Then - Implementation intention
 * 4. Question - Reflective question
 * 5. Quote - Verified memorable quote (from Quote Bank only)
 *
 * @module HeroInsight
 */

import { readFileSync, existsSync } from 'fs';
import { homedir } from 'os';

// Import new dossier-based modules
import type {
  HeroCard as ParsedHeroCard,
  DailyContext as ParsedDailyContext,
  HeroInsight as ParsedHeroInsight,
  VerifiedQuote,
  ContextTag,
} from './types.ts';
import { parseAllDossiers } from './HeroDossierParser.ts';
import { selectHeroForContext, getContextTags as getContextTagsNew } from './HeroSelector.ts';
import {
  generateInsight,
  formatHeroInsightForTelegram as formatInsightNew,
} from './InsightGenerator.ts';

// ============================================================================
// Paths
// ============================================================================

const DOSSIERS_DIR = `${homedir()}/.claude/skills/DailyBriefing/Data/HeroDossiers`;
const CACHE_FILE = `${homedir()}/.claude/skills/DailyBriefing/Data/ParsedHeroes/heroes.json`;
const HERO_COUNCIL_PATH = `${homedir()}/.claude/skills/DailyBriefing/Data/hero-council.json`;

// ============================================================================
// Legacy Types (Backward Compatibility)
// ============================================================================

/**
 * Legacy Hero interface for backward compatibility
 * @deprecated Use HeroCard from types.ts instead
 */
export interface Hero {
  id: string;
  name: string;
  domain: string;
  principles: string[];
  actions: string[];
  ifThens: string[];
  questions: string[];
  quotes: string[];
  contexts: LegacyContextTag[];
}

/**
 * Legacy HeroCard interface
 * @deprecated Use HeroCard from types.ts instead
 */
export interface HeroCard {
  id: string;
  name: string;
  title: string;
  era: string;
  domain: string;
  principles: string[];
  contextTriggers: {
    keywords: string[];
    situations: string[];
    metrics: Record<string, boolean>;
  };
  insightTemplate: {
    morningGreeting: string;
    focusAdvice: string;
    challengeReframe: string;
    actionPrompt: string;
    closingWisdom: string;
  };
  actions: string[];
  ifThens: string[];
  questions: string[];
  quotes?: HeroQuote[];
  contexts: LegacyContextTag[];
}

export interface HeroQuote {
  text: string;
  source: string;
  verified: boolean;
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

type LegacyContextTag =
  | 'low_recovery'
  | 'high_recovery'
  | 'workout_day'
  | 'rest_day'
  | 'monday'
  | 'weekend'
  | 'any';

/**
 * Daily context for hero selection
 */
export interface DailyContext {
  recoveryScore: number;
  sleepScore: number;
  hasWorkout: boolean;
  workoutType: string | null;
  dayOfWeek: string;
  calendarEvents?: CalendarEvent[];
  // Extended fields from new system
  hrvStatus?: 'Low' | 'Normal' | 'High';
  bodyBattery?: number;
  workoutIntensity?: 'easy' | 'moderate' | 'hard' | null;
  hasImportantEvent?: boolean;
  calendarKeywords?: string[];
}

export interface CalendarEvent {
  title: string;
  time: string;
  description?: string;
}

/**
 * Legacy HeroInsight interface
 */
export interface HeroInsight {
  hero: Hero | { name: string; domain: string; id: string };
  principle: string;
  action: string;
  ifThen: string;
  question: string;
  quote: string | VerifiedQuote;
}

// ============================================================================
// Hero Loading (New Dossier-Based System)
// ============================================================================

let _cachedHeroes: ParsedHeroCard[] | null = null;

/**
 * Load heroes from cached JSON or parse dossiers on demand
 */
function loadHeroes(): ParsedHeroCard[] {
  if (_cachedHeroes) {
    return _cachedHeroes;
  }

  // Try loading from cache first (fast path)
  if (existsSync(CACHE_FILE)) {
    try {
      const cacheContent = JSON.parse(readFileSync(CACHE_FILE, 'utf-8'));
      _cachedHeroes = cacheContent.heroes || cacheContent;
      return _cachedHeroes!;
    } catch (error) {
      console.error('Failed to load hero cache, falling back to parsing:', error);
    }
  }

  // Fallback: parse dossiers directly (slower but always works)
  if (existsSync(DOSSIERS_DIR)) {
    _cachedHeroes = parseAllDossiers(DOSSIERS_DIR);
    return _cachedHeroes;
  }

  // Last resort: return empty array
  console.error('No hero dossiers found');
  return [];
}

// ============================================================================
// Backward Compatibility Functions
// ============================================================================

// Keywords to extract from calendar events
const RELEVANT_KEYWORDS = [
  'run', 'running', 'workout', 'training', 'lift', 'lifting', 'hard', 'intense',
  'team', 'leadership', 'meeting', 'presentation', 'stress', 'challenge',
  'difficult', 'important', 'critical', 'deadline', 'interview', 'review',
  'marathon', 'race', 'competition', 'yoga', 'meditation', 'recovery',
  'therapy', 'doctor', 'appointment', 'travel', 'flight',
];

/**
 * Validate a single HeroCard (legacy)
 * @deprecated Use new dossier validation instead
 */
export function validateHeroCard(hero: HeroCard): ValidationResult {
  const errors: string[] = [];

  if (!hero.id) errors.push('Missing required field: id');
  if (!hero.name) errors.push('Missing required field: name');
  if (!hero.domain) errors.push('Missing required field: domain');
  if (!hero.principles || hero.principles.length === 0) {
    errors.push('Hero must have at least one principle');
  }

  if (!hero.insightTemplate) {
    errors.push('Missing required field: insightTemplate');
  } else {
    const required = ['morningGreeting', 'focusAdvice', 'challengeReframe', 'actionPrompt', 'closingWisdom'];
    for (const field of required) {
      if (!(hero.insightTemplate as any)[field]) {
        errors.push(`Missing insightTemplate field: ${field}`);
      }
    }
  }

  if (hero.quotes && hero.quotes.length > 0) {
    for (const quote of hero.quotes) {
      if (typeof quote.verified !== 'boolean') {
        errors.push(`Quote must have verified flag: "${quote.text?.substring(0, 30)}..."`);
      }
    }
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Validate a hero council (legacy)
 * @deprecated Use new dossier validation instead
 */
export function validateHeroCouncil(heroes: HeroCard[]): ValidationResult {
  const errors: string[] = [];

  if (heroes.length === 0) {
    errors.push('Hero council must have at least one hero');
    return { valid: false, errors };
  }

  const ids = new Set<string>();
  for (const hero of heroes) {
    if (hero.id && ids.has(hero.id)) {
      errors.push(`Duplicate hero id: ${hero.id}`);
    }
    ids.add(hero.id);

    const heroResult = validateHeroCard(hero);
    if (!heroResult.valid) {
      errors.push(...heroResult.errors.map(e => `[${hero.id || 'unknown'}] ${e}`));
    }
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Load hero council from a JSON file (legacy)
 * @deprecated Use loadHeroes() instead
 */
export function loadHeroCouncilFromFile(filePath: string): HeroCard[] {
  if (!existsSync(filePath)) {
    throw new Error(`Hero council file not found: ${filePath}`);
  }

  const content = readFileSync(filePath, 'utf-8');
  let data: any;

  try {
    data = JSON.parse(content);
  } catch (e) {
    throw new Error(`Invalid JSON in hero council file: ${filePath}`);
  }

  const heroes = data.heroes || data;

  if (!Array.isArray(heroes)) {
    throw new Error(`Hero council file must contain an array of heroes: ${filePath}`);
  }

  const validation = validateHeroCouncil(heroes);
  if (!validation.valid) {
    throw new Error(`Invalid hero council: ${validation.errors.join(', ')}`);
  }

  return heroes;
}

/**
 * Extract relevant keywords from calendar events
 */
export function analyzeCalendarContext(events: CalendarEvent[]): string[] {
  if (!events || events.length === 0) {
    return [];
  }

  const keywords: string[] = [];

  for (const event of events) {
    if (!event.title) continue;

    const words = event.title.toLowerCase().split(/[\s\-_,]+/);
    for (const word of words) {
      if (RELEVANT_KEYWORDS.includes(word) && !keywords.includes(word)) {
        keywords.push(word);
      }
    }
  }

  return keywords;
}

/**
 * Get a random verified quote from a hero card (legacy)
 */
export function getRandomVerifiedQuote(hero: HeroCard): HeroQuote | undefined {
  if (!hero.quotes || hero.quotes.length === 0) {
    return undefined;
  }

  const verifiedQuotes = hero.quotes.filter(q => q.verified === true);
  if (verifiedQuotes.length === 0) {
    return undefined;
  }

  return verifiedQuotes[Math.floor(Math.random() * verifiedQuotes.length)];
}

// ============================================================================
// Legacy Hero Database (Fallback Only)
// ============================================================================

/**
 * Legacy hardcoded heroes - used as fallback if dossiers unavailable
 * @deprecated Use parsed dossiers instead
 */
export const heroes: Hero[] = [
  {
    id: 'marcus-aurelius',
    name: 'Marcus Aurelius',
    domain: 'philosophy',
    principles: [
      'Control what you can control; accept what you cannot.',
      'The obstacle is the way - use adversity as fuel.',
      'Begin each day by telling yourself: I shall meet interference.',
    ],
    actions: [
      'Identify one thing outside your control today and release it.',
      'Reframe today\'s biggest challenge as an opportunity.',
    ],
    ifThens: [
      'If I encounter an obstacle, then I will ask: How can this make me stronger?',
      'If I feel anxious, then I will focus only on my next action.',
    ],
    questions: [
      'What is within my control right now?',
      'How would my best self handle this situation?',
    ],
    quotes: [
      '"The impediment to action advances action. What stands in the way becomes the way."',
      '"Waste no more time arguing about what a good man should be. Be one."',
    ],
    contexts: ['low_recovery', 'any', 'monday'],
  },
  // ... additional fallback heroes omitted for brevity
];

// ============================================================================
// Main API (Uses New Dossier System)
// ============================================================================

/**
 * Convert legacy context to new ParsedDailyContext
 */
function convertContext(context: DailyContext): ParsedDailyContext {
  return {
    recoveryScore: context.recoveryScore,
    sleepScore: context.sleepScore,
    hasWorkout: context.hasWorkout,
    workoutType: context.workoutType,
    dayOfWeek: context.dayOfWeek,
    hrvStatus: context.hrvStatus,
    bodyBattery: context.bodyBattery,
    workoutIntensity: context.workoutIntensity,
    hasImportantEvent: context.hasImportantEvent,
    calendarKeywords: context.calendarKeywords || analyzeCalendarContext(context.calendarEvents || []),
    calendarEvents: context.calendarEvents,
  };
}

/**
 * Select a hero based on context
 * Now uses dossier-based selection with proper context matching
 */
export function selectHero(context: DailyContext, heroPool?: Hero[]): Hero {
  // Use new dossier-based system
  const parsedHeroes = loadHeroes();

  if (parsedHeroes.length === 0) {
    // Fallback to legacy heroes if dossiers unavailable
    if (heroPool && heroPool.length > 0) {
      return heroPool[Math.floor(Math.random() * heroPool.length)];
    }
    return heroes[Math.floor(Math.random() * heroes.length)];
  }

  const parsedContext = convertContext(context);
  const selected = selectHeroForContext(parsedContext, parsedHeroes);

  // Convert ParsedHeroCard to legacy Hero format for compatibility
  return {
    id: selected.id,
    name: selected.name,
    domain: selected.domain,
    principles: selected.operatingPrinciples,
    actions: selected.signatureTactics,
    ifThens: [],  // Generated dynamically now
    questions: [], // Generated dynamically now
    quotes: selected.quotes.map(q => `"${q.text}"`),
    contexts: ['any'] as LegacyContextTag[],
  };
}

/**
 * Get hero insight based on context
 * Now uses dossier-based system with verified quotes only
 */
export function getHeroInsight(
  context: DailyContext,
  heroPool?: Hero[]
): HeroInsight | null {
  const parsedHeroes = loadHeroes();

  if (parsedHeroes.length === 0) {
    // Fallback if no dossiers available
    console.warn('No parsed heroes available, using legacy system');
    return getLegacyHeroInsight(context, heroPool);
  }

  const parsedContext = convertContext(context);
  const selectedHero = selectHeroForContext(parsedContext, parsedHeroes);
  const insight = generateInsight(selectedHero, parsedContext);

  // Convert to legacy format for backward compatibility with briefing.ts
  return {
    hero: {
      name: insight.hero.name,
      domain: insight.hero.domain,
      id: insight.hero.id,
    },
    principle: insight.principle,
    action: insight.action,
    ifThen: insight.ifThen,
    question: insight.question,
    quote: insight.quote, // Now VerifiedQuote object
  };
}

/**
 * Legacy insight generation (fallback)
 */
function getLegacyHeroInsight(
  context: DailyContext,
  heroPool: Hero[] = heroes
): HeroInsight | null {
  if (heroPool.length === 0) {
    return null;
  }

  const hero = heroPool[Math.floor(Math.random() * heroPool.length)];

  const randomPick = <T>(arr: T[] | undefined): T | undefined => {
    if (!arr || arr.length === 0) return undefined;
    return arr[Math.floor(Math.random() * arr.length)];
  };

  return {
    hero,
    principle: randomPick(hero.principles) || 'Focus on what matters.',
    action: randomPick(hero.actions) || 'Take one meaningful action today.',
    ifThen: randomPick(hero.ifThens) || 'If challenged, then I will persevere.',
    question: randomPick(hero.questions) || 'What truly matters today?',
    quote: randomPick(hero.quotes) || '"Excellence is a habit."',
  };
}

// ============================================================================
// Telegram Formatting
// ============================================================================

/**
 * Format hero insight for Telegram HTML output
 * Handles both new VerifiedQuote format and legacy string quotes
 */
export function formatHeroInsightForTelegram(insight: HeroInsight | null): string {
  if (!insight) {
    return '';
  }

  // Handle quote - can be VerifiedQuote object or legacy string
  let quoteText: string;
  let quoteSource: string | null = null;

  if (typeof insight.quote === 'object' && insight.quote !== null) {
    // New VerifiedQuote format
    quoteText = insight.quote.text;
    quoteSource = insight.quote.source;
  } else {
    // Legacy string format
    quoteText = String(insight.quote);
  }

  // Get hero info - handle both formats
  const heroName = 'name' in insight.hero ? insight.hero.name : (insight.hero as any).name;
  const heroDomain = 'domain' in insight.hero ? insight.hero.domain : (insight.hero as any).domain;

  let output = `
<b>HERO INSIGHT</b>
<i>${heroName} on ${heroDomain}</i>

<b>Principle:</b> ${insight.principle}

<b>Action:</b> ${insight.action}

<b>Implementation:</b> ${insight.ifThen}

<b>Reflect:</b> ${insight.question}

<code>---------------------------------</code>
<i>"${quoteText}"</i>`;

  if (quoteSource) {
    output += `\n<i>- ${quoteSource}</i>`;
  }

  return output.trim();
}

// ============================================================================
// CLI Entry Point
// ============================================================================

if (import.meta.main) {
  const testContext: DailyContext = {
    recoveryScore: 75,
    sleepScore: 70,
    hasWorkout: true,
    workoutType: 'running',
    dayOfWeek: new Date().toLocaleDateString('en-US', { weekday: 'long' }),
  };

  console.log('Testing HeroInsight with context:', testContext);
  console.log('\n--- Using New Dossier-Based System ---\n');

  const heroes = loadHeroes();
  console.log(`Loaded ${heroes.length} heroes from dossiers\n`);

  const insight = getHeroInsight(testContext);
  if (insight) {
    console.log(formatHeroInsightForTelegram(insight));
  } else {
    console.log('No insight generated');
  }
}
